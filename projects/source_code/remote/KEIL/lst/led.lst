C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LED
OBJECT MODULE PLACED IN .\Output\led.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\led.c LARGE OMF2 OPTIMIZE(1,SPEED) BROWSE INCDIR(..\..\..\..\Library\
                    -Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\lst\led.lst) TABS(2) OBJECT(.\Output\led.obj)

line level    source

   1          /*
   2           * led.c
   3           *
   4           * Copyright 2014 Edward V. Emelianoff <eddy@sao.ru>
   5           *
   6           * This program is free software; you can redistribute it and/or modify
   7           * it under the terms of the GNU General Public License as published by
   8           * the Free Software Foundation; either version 2 of the License, or
   9           * (at your option) any later version.
  10           *
  11           * This program is distributed in the hope that it will be useful,
  12           * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14           * GNU General Public License for more details.
  15           *
  16           * You should have received a copy of the GNU General Public License
  17           * along with this program; if not, write to the Free Software
  18           * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  19           * MA 02110-1301, USA.
  20           */
  21          
  22          #include "numicro_8051.h"
*** WARNING C320 IN LINE 576 OF \nuvoton\remote_keil\Library\Device\Include\function_define_N76E003.h: "Taken from other
             - CPU!!! May not work"
  23          #include "led.h"
  24          
  25          /*
  26           * bits no     7   6   5   4   3   2   1   0
  27           * dec value  128  64  32  16  8   4   2   1
  28           */
  29          
  30          /********** one variant **********/
  31          /*
  32           * One digit:                          TABLE:
  33           *   ***A***                   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F - h
  34           *   *     *         (A) PB4   0  1  0  0  1  0  0  0  0  0  0  1  0  1  0  0 1 1
  35           *   F     B         (F) PB5   0  1  1  1  0  0  0  1  0  0  0  0  0  1  0  0 1 0
  36           *   *     *         (B) PC5   0  0  0  0  0  1  1  0  0  0  0  1  1  0  1  1 1 1
  37           *   ***G***         (G) PC6   1  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0 0 0
  38           *   *     *         (C) PC7   0  0  1  0  0  0  0  0  0  0  0  0  1  0  1  1 1 0
  39           *   E     C         (E) PD1   0  1  0  1  1  1  0  1  0  1  0  0  0  0  0  0 1 0
  40           *   *     *   **    (D) PD2   0  1  0  0  1  0  0  1  0  0  1  0  0  0  0  1 1 1
  41           *   ***D***  *DP*   (DP)PD3   1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 1 1
  42           *             **
  43           */
  44          /*
  45          // PB, mask: 0x30, PB4: 0x10, PB5: 0x20
  46          #define PB_BLANK 0x30
  47          static U8 PB_bits[18] = {0,0x30,0x20,0x20,0x10,0,0,0x20,0,0,0,0x10,0,0x30,0,0,0x30,0x10};
  48          // PC, mask: 0xe0, PC5: 0x20, PC6: 0x40, PC7: 0x80
  49          #defin PC_BLANK 0xe0
  50          static U8 PC_bits[18] = {0x40,0x40,0x80,0,0,0x20,0x20,0x40,0,0,0,0x20,0xe0,0,0xa0,0xa0,0xa0,0x20};
  51          // PD, mask: 0x0e, PD1: 0x02, PD2: 0x04, PD3: 0x08
  52          #define PD_BLANK 0x0e
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 2   

  53          static U8 PD_bits[18] = {0x08,0x0e,0x08,0x0a,0x0e,0x0a,0x08,0x0e,0x08,0x0a,0x0c,0x8,0x08,0x08,0x08,0x0c,0x
             -0e,0x0c};
  54          */
  55          /*
  56           * Number of digit on indicator with common anode
  57           * digis 0..3: PC3, PC4, PA3, PD4
  58           */
  59          
  60          
  61          /********** current variant **********/
  62          /*
  63           * One digit:                          TABLE:
  64           *   ***A***                   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  -  h
  65           *   *     *         (F) PA1   0  1  1  1  0  0  0  1  0  0  0  0  0  1  0  0  1  0
  66           *   F     B         (B) PB4   0  0  0  0  0  1  1  0  0  0  0  1  1  0  1  1  1  1
  67           *   *     *         (A) PB5   0  1  0  0  1  0  0  0  0  0  0  1  0  1  0  0  1  1
  68           *   ***G***         (G) PC3   1  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0
  69           *   *     *         (C) PC4   0  0  1  0  0  0  0  0  0  0  0  0  1  0  1  1  1  0
  70           *   E     C         (DP)PC5   1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
  71           *   *     *   **    (D) PC6   0  1  0  0  1  0  0  1  0  0  1  0  0  0  0  1  1  1
  72           *   ***D***  *DP*   (E) PC7   0  1  0  1  1  1  0  1  0  1  0  0  0  0  0  0  1  0
  73           *             **
  74           */
  75          
  76          /*
  77           * Number of digit on indicator with common anode
  78           * digis 0..3: PA3, PD6, PD4, PD1
  79           */
  80          
  81          /************* arrays for ports *************/
  82          static const U8 LED_bits[18] = {0xfe,0x30,0xed,0xf9,0x33,0xdb,0xdf,0xf0,0xff,0xfb,
  83                                    0xf7,0x3f,0x0d,0x3d,0xcf,0xe7,0x01,0};
  84          
  85          /**
  86           * Turn on anode power for digit N (0..3: PA3, PD6, PD4, PD1 -- A0x08, D0x40, D0x10, D0x02)
  87           * @param N - number of digit (0..3), if other - no action (display off)
  88           * @return
  89           */
  90          void light_up_digit(U8 N){
  91   1        switch(N){
  92   2          case 0:
  93   2            #ifndef INVERT_SMALL_DIGITS 
                     P01 = 1; // Digit 1
                    #else
  96   2             P01 = 0; // Digit 1
  97   2            #endif
  98   2          break;
  99   2          case 1:
 100   2            #ifndef INVERT_SMALL_DIGITS 
                     P12 = 1; // Digit 2
                    #else
 103   2             P12 = 0; // Digit 2
 104   2            #endif
 105   2          break;
 106   2          case 2: 
 107   2             P04 = 1; // Digit 3
 108   2          break;
 109   2          case 3:
 110   2             P11 = 1; // Digit 4
 111   2          break;
 112   2          case 4:
 113   2            #ifndef INVERT_SMALL_DIGITS 
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 3   

                     P03 = 1; // Digit 5
                    #else
 116   2             P03 = 0; // Digit 5
 117   2            #endif
 118   2          break;
 119   2          case 5:
 120   2            #ifndef INVERT_SMALL_DIGITS 
                     P00 = 1; // Digit 6
                    #else
 123   2             P00 = 0; // Digit 6
 124   2            #endif
 125   2          break;
 126   2        }
 127   1      }
 128          
 129          void light_off_digit(U8 N){
 130   1        switch(N){
 131   2          case 0:
 132   2            #ifndef INVERT_SMALL_DIGITS 
                     P01 = 0; // Digit 1
                    #else
 135   2             P01 = 1; // Digit 1
 136   2            #endif
 137   2          break;
 138   2          case 1:
 139   2            #ifndef INVERT_SMALL_DIGITS 
                     P12 = 0; // Digit 2
                    #else
 142   2             P12 = 1; // Digit 2
 143   2            #endif
 144   2          break;
 145   2          case 2:
 146   2             P04 = 0; // Digit 3
 147   2          break;
 148   2          case 3:
 149   2             P11 = 0; // Digit 4
 150   2          break;
 151   2          case 4:
 152   2            #ifndef INVERT_SMALL_DIGITS 
                     P03 = 0; // Digit 5
                    #else
 155   2             P03 = 1; // Digit 5
 156   2            #endif
 157   2          break;
 158   2          case 5:
 159   2            #ifndef INVERT_SMALL_DIGITS 
                     P00 = 0; // Digit 6
                    #else
 162   2             P00 = 1; // Digit 6
 163   2            #endif
 164   2          break;
 165   2        }
 166   1      }
 167          
 168          
 169          static U8 display_buffer[6] = {' ',' ',' ',' ',' ',' '}; // blank by default
 170          U8 N_current = 0; // current digit to display
 171          
 172          /**
 173           * fills buffer to display
 174           * @param str - string to display, contains "0..f" for digits, " " for space, "." for DP
 175           *        for example: " 1.22" or "h1ab" (something like "0...abc" equivalent to "0.abc"
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 4   

 176           *        register independent!
 177           *      any other letter would be omitted
 178           *      if NULL - fill buffer with spaces
 179           */
 180          void set_display_buf(char *str){
 181   1        U8 B[4];
 182   1        signed char ch, M = 0, i;
 183   1        //N_current = 0; // refresh current digit number
 184   1        // empty buffer
 185   1        for(i = 0; i < 6; i++)
 186   1          display_buffer[i] = ' ';
 187   1        if(!str) return;
 188   1        i = 0;
 189   1        for(;(ch = *str) && (i < 6); str++){
 190   2          M = 0;
 191   2          if(ch > '/' && ch < ':'){ // digit
 192   3            M = '0';
 193   3          }else if(ch > '`' & ch < 'g'){ // a..f
 194   3            M = 'a' - 10;
 195   3          }else if(ch > '@' & ch < 'G'){ // A..F
 196   3            M = 'A' - 10;
 197   3          }else if(ch == '-'){ // minus
 198   3            M = '-' - 16;
 199   3          }else if(ch == 'h'){ // hex
 200   3            M = 'h' - 17;
 201   3          }else if(ch == 'H'){ // hex
 202   3            M = 'H' - 17;
 203   3          }else if(ch == '.'){ // DP, set it to previous char
 204   3            if(i == 0){ // word starts from '.' - make a space with point
 205   4              B[0] = 0xff;
 206   4            }else{ // set point for previous character
 207   4              B[i-1] |= 0x80;
 208   4            }
 209   3            continue;
 210   3          }else if(ch != ' '){ // bad character - continue
 211   3            continue;
 212   3          }
 213   2          B[i] = ch - M;
 214   2          i++;
 215   2        }
 216   1        // now make align to right
 217   1        ch = 5;
 218   1        for(M = i-1; M > -1; M--, ch--){
 219   2          display_buffer[ch] = B[M];
 220   2        }
 221   1      }
 222          
 223          /**
 224           * Show Nth digit of buffer (function ran by timer)
 225           * @param N - number of digit in buffer (0..3)
 226           */
 227          /**
 228          * Setup for writing a letter
 229          * @param ltr - letter (0..17 for 0..F, - or h | 0x80 for DP, any other value for 'space')
 230          */
 231          void show_buf_digit(U8 N){
 232   1        U8 L;
 233   1        U8 i;
 234   1        U8 b = 1;
 235   1      
 236   1        if(N > 5) return;
 237   1        
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 5   

 238   1      //  write_letter(display_buffer[N]);
 239   1        L = display_buffer[N] & 0x7f;
 240   1      //  all_digits_off();
 241   1        if(L < 18){ // letter
 242   2          L = LED_bits[L];
 243   2        }else{ // space
 244   2          L = 0;
 245   2        }
 246   1        if(N == 0) {
 247   2          light_off_digit(5);
 248   2        }
 249   1        else {
 250   2          light_off_digit(N-1);
 251   2        }
 252   1        for (i = 0; i<7; i++)
 253   1        {
 254   2          CLOCK = 0; // Clear CLK
 255   2      //    _asm("nop");
 256   2      //    _asm("nop");
 257   2      #ifdef INVERT_SMALL_DIGITS    
 258   2          if((N==2 || N== 3)) b = 1;
 259   2          else b = 0;
 260   2      #endif  
 261   2          if((L>>i) & 1)    
 262   2          {
 263   3            DATA = !b; // Set LED on
 264   3          }
 265   2          else
 266   2          {
 267   3            DATA = b; // Set LED OFF
 268   3          }
 269   2          CLOCK = 1; // Set CLK - rising edge transfers data
 270   2      //    _asm("nop");
 271   2      //    _asm("nop");
 272   2        }
 273   1      
 274   1        light_up_digit(N);
 275   1      }
 276          
 277          /**
 278           * Show next digit - function calls from main() by some system time value amount
 279           */
 280          void show_next_digit(void){
 281   1        show_buf_digit(N_current++);
 282   1        if(N_current > 5) N_current = 0;
 283   1      }
 284          
 285          
 286          
 287          /**
 288           * convert integer value in into string and display it
 289           * @param i - value to display, -999999 <= i <= 999999, if wrong, displays "---E"
 290           */
 291          void display_int(S32 I){
 292   1        signed char rem;
 293   1        signed char i;
 294   1        signed char sign = 0;
 295   1        if(I < -999999 || I > 999999){
 296   2          set_display_buf("--EE--");
 297   2          return;
 298   2        }
 299   1      //  set_display_buf(NULL); // empty buffer
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 6   

 300   1        for(i = 0; i < 6; i++)
 301   1          display_buffer[i] = 0;
 302   1        if(I == 0){ // just show zero
 303   2          return;
 304   2        }
 305   1        if(I < 0){
 306   2          sign = 1;
 307   2          I *= -1;
 308   2        }
 309   1        for (i = 0; i < 6; i++)
 310   1        {
 311   2          rem = I - (I/10)*10;
 312   2          display_buffer[5-i] = rem; //rem;
 313   2          I = I/10;
 314   2          if(I == 0) break;
 315   2        }
 316   1        if(sign && i < 6) display_buffer[5-i] = 16; // minus sign
 317   1      }
 318          
 319          
 320          /**
 321           * convert integer value in seconds and minutes into string and display it
 322           * @param i - value to display, -999 <= i <= 9999, if wrong, displays "---E"
 323           */
 324          void display_int_sec(S32 I){
 325   1        S32 rem;
 326   1        signed char i;
 327   1        signed char N = 5;
 328   1      
 329   1        for(i = 0; i < 6; i++)
 330   1          display_buffer[i] = 0;
 331   1        if(I == 0){ // just show zero
 332   2          return;
 333   2        }
 334   1      
 335   1        I = I/3600 * 10000 + ((I - (I/3600)*3600)/60)* 100 + (I - (I/60)*60);
 336   1        do{
 337   2          rem = I - (I/10)*10;
 338   2          display_buffer[N] = rem;
 339   2          I /= 10;
 340   2        }while(--N > -1 && I);
 341   1      }
 342          
 343          
 344          /**
 345           * displays digital point at position i
 346           * @param i - position to display DP, concequent calls can light up many DPs
 347           */
 348          void display_DP_at_pos(U8 i){
 349   1        if(i > 5) return;
 350   1        display_buffer[i] |= 0x80;
 351   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1793    ----
   CONSTANT SIZE    =      7    ----
   XDATA SIZE       =     59    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.60.7.0   LED                                                               02/22/2025 21:59:20 PAGE 7   

   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
