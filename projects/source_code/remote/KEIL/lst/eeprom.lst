C51 COMPILER V9.60.7.0   EEPROM                                                            02/22/2025 21:59:20 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Output\eeprom.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\..\..\Library\StdDriver\src\eeprom.c LARGE OMF2 OPTIMIZE(1,SPEED) 
                    -BROWSE INCDIR(..\..\..\..\Library\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\lst\eeprom.lst) TABS(2
                    -) OBJECT(.\Output\eeprom.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* SPDX-License-Identifier: Apache-2.0                                                                    
             - */
   4          /* Copyright(c) 2023 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   5          /*                                                                                                        
             - */
   6          /*--------------------------------------------------------------------------------------------------------
             --*/
   7          #include "numicro_8051.h"
*** WARNING C320 IN LINE 576 OF \nuvoton\remote_keil\Library\Device\Include\function_define_N76E003.h: "Taken from other
             - CPU!!! May not work"
   8          
   9          #if defined __C51__
  10          volatile uint8_t xdata page_buffer[128];
  11          volatile uint8_t xdata xd_tmp[128];
  12          
  13          #elif defined __ICC8051__
              uint8_t __xdata page_buffer[128];
              uint8_t __xdata xd_tmp[128];
              
              #elif defined __SDCC__
              uint8_t __xdata page_buffer[128];
              uint8_t __xdata xd_tmp[128];
              #endif
  21          
  22          uint8_t WriteDataToOnePage(uint16_t u16_addr,const uint8_t *pDat,uint8_t num);
  23          
  24          /**
  25           * @brief       Write Dataflash as EEPROM, 
  26           * @param       u16EPAddr the 16bit EEPROM start address. Any of APROM address can be defined as start add
             -ress (0x3800)
  27           * @param       u8EPData the 8bit value need storage in (0x3800)
  28           * @return      none
  29           * @details     Storage dataflash page data into XRAM 380H-400H, modify data in XRAM, Erase dataflash page
             -, writer updated XRAM data into dataflash
  30           */
  31          void Write_DATAFLASH_BYTE(uint16_t u16EPAddr, uint8_t u8EPData)
  32          {
  33   1          uint8_t   looptmp=0;
  34   1          uint16_t  u16_addrl_r;
  35   1          uint8_t   RAMtmp;
  36   1      
  37   1        /* Check page start address  */
  38   1          u16_addrl_r=(u16EPAddr/128)*128;
  39   1        /*Save APROM data to XRAM0  */
  40   1          for(looptmp=0;looptmp<0x80;looptmp++)
  41   1          {
  42   2      #if defined __C51__
  43   2              RAMtmp = Read_APROM_BYTE((uint16_t code *)(u16_addrl_r+looptmp));
C51 COMPILER V9.60.7.0   EEPROM                                                            02/22/2025 21:59:20 PAGE 2   

  44   2      #elif defined __ICC8051__
                      RAMtmp = Read_APROM_BYTE((uint16_t __code *)(u16_addrl_r+looptmp));
              #elif defined __SDCC__
                      RAMtmp = Read_APROM_BYTE((uint16_t __code *)(u16_addrl_r+looptmp));
              #endif
  49   2              page_buffer[looptmp]=RAMtmp;
  50   2          }
  51   1      // Modify customer data in XRAM
  52   1          page_buffer[u16EPAddr&0x7f] = u8EPData;
  53   1      
  54   1      //Erase APROM DATAFLASH page
  55   1          IAPAL = u16_addrl_r&0xff;
  56   1          IAPAH = (u16_addrl_r>>8)&0xff;
  57   1          IAPFD = 0xFF;
  58   1          set_CHPCON_IAPEN; 
  59   1          set_IAPUEN_APUEN;
  60   1          IAPCN = 0x22;     
  61   1           set_IAPTRG_IAPGO; 
  62   1          
  63   1      //Save changed RAM data to APROM DATAFLASH
  64   1          set_CHPCON_IAPEN; 
  65   1          set_IAPUEN_APUEN;
  66   1          IAPCN = 0x21;
  67   1          for(looptmp=0;looptmp<0x80;looptmp++)
  68   1          {
  69   2              IAPAL = (u16_addrl_r&0xff)+looptmp;
  70   2              IAPAH = (u16_addrl_r>>8)&0xff;
  71   2              IAPFD = page_buffer[looptmp];
  72   2              set_IAPTRG_IAPGO;      
  73   2          }
  74   1          clr_IAPUEN_APUEN;
  75   1          clr_CHPCON_IAPEN;
  76   1      }
  77          
  78          
  79          //-------------------------------------------------------------------------
  80          void Write_DATAFLASH_ARRAY(uint16_t u16_addr, uint8_t *pDat, uint16_t num)
  81          {
  82   1        uint8_t CPageAddr,EPageAddr,cnt;
  83   1      
  84   1        CPageAddr=u16_addr>>7;
  85   1        EPageAddr=(u16_addr+num)>>7;
  86   1        while(CPageAddr!=EPageAddr)
  87   1        {
  88   2          cnt=WriteDataToOnePage(u16_addr,pDat,128);
  89   2          u16_addr+=cnt;
  90   2          pDat+=cnt;
  91   2          num-=cnt;
  92   2          CPageAddr=u16_addr>>7;
  93   2        }
  94   1        if(num)
  95   1        {
  96   2          WriteDataToOnePage(u16_addr,pDat,num);
  97   2        }
  98   1      }
  99          //-------------------------------------------------------------------------
 100          void Read_DATAFLASH_ARRAY(uint16_t u16_addr, uint8_t *pDat, uint16_t num)
 101          {
 102   1          uint16_t i;
 103   1      
 104   1          for(i=0;i<num;i++)
 105   1          {
C51 COMPILER V9.60.7.0   EEPROM                                                            02/22/2025 21:59:20 PAGE 3   

 106   2      #if defined __C51__
 107   2              pDat[i] = *(uint8_t code *)(u16_addr+i);
 108   2      #elif defined __ICC8051__
                      pDat[i] = *(uint8_t __code *)(u16_addr+i);
              #elif defined __SDCC__
                      pDat[i] = *(uint8_t __code *)(u16_addr+i);
              #endif
 113   2          }
 114   1      }
 115          
 116          //--------------------------------------------------------------------------------------------------------
             ----
 117          uint8_t WriteDataToOnePage(uint16_t u16_addr,const uint8_t *pDat,uint8_t num)
 118          {
 119   1      
 120   1      #if defined __C51__
 121   1        uint8_t code *pCode;
 122   1      #elif defined __ICC8051__
                uint8_t __code *pCode;
              #elif defined __SDCC__
                uint8_t __code *pCode;
              #endif
 127   1        uint8_t i,offset;
 128   1      
 129   1          set_CHPCON_IAPEN; 
 130   1          set_IAPUEN_APUEN;
 131   1      
 132   1          offset=u16_addr&0x007F;
 133   1          i = PAGE_SIZE - offset;
 134   1          if(num>i)num=i;
 135   1      #if defined __C51__
 136   1          pCode = (uint8_t code *)u16_addr;
 137   1      #elif defined __ICC8051__
                  pCode = (uint8_t __code *)u16_addr;
              #elif defined __SDCC__
                  pCode = (uint8_t __code *)u16_addr;
              #endif
 142   1      
 143   1          for(i=0;i<num;i++)
 144   1          {
 145   2              if(pCode[i]!=0xFF)break;
 146   2          }
 147   1          if(i==num)
 148   1          {
 149   2              IAPCN =BYTE_PROGRAM_APROM;
 150   2              IAPAL = u16_addr;
 151   2              IAPAH = u16_addr>>8;
 152   2              for(i=0;i<num;i++)
 153   2              {
 154   3                IAPFD = pDat[i];
 155   3                set_IAPTRG_IAPGO;
 156   3                IAPAL++;
 157   3              }
 158   2              for(i=0;i<num;i++)
 159   2              {
 160   3                if(pCode[i]!=pDat[i])break;
 161   3              }
 162   2              if(i!=num) goto WriteDataToPage20;
 163   2          }
 164   1          else
 165   1          {
 166   2      WriteDataToPage20:
C51 COMPILER V9.60.7.0   EEPROM                                                            02/22/2025 21:59:20 PAGE 4   

 167   2      #if defined __C51__
 168   2              pCode = (uint8_t code *)(u16_addr&0xff80);
 169   2      #elif defined __ICC8051__
                      pCode = (uint8_t __code *)(u16_addr&0xff80);
              #elif defined __SDCC__
                      pCode = (uint8_t __code *)(u16_addr&0xff80);
              #endif
 174   2      
 175   2              for(i=0;i<128;i++)
 176   2              {
 177   3                xd_tmp[i] = pCode[i];
 178   3              }
 179   2              for(i=0;i<num;i++)
 180   2              {
 181   3                xd_tmp[offset+i] = pDat[i];
 182   3              }
 183   2              do
 184   2              {
 185   3                IAPAL = (u16_addr&0xff80);
 186   3                IAPAH = u16_addr>>8;
 187   3                IAPCN = PAGE_ERASE_APROM;
 188   3                IAPFD = 0xFF;  
 189   3                set_IAPTRG_IAPGO; 
 190   3                IAPCN =BYTE_PROGRAM_APROM;
 191   3                for(i=0;i<128;i++)
 192   3                {
 193   4                  IAPFD = xd_tmp[i];
 194   4                  set_IAPTRG_IAPGO;
 195   4                  IAPAL++;
 196   4                }
 197   3                for(i=0;i<128;i++)
 198   3                {
 199   4                  if(pCode[i]!=xd_tmp[i])break;
 200   4                }
 201   3              }while(i!=128);
 202   2          }
 203   1          clr_CHPCON_IAPEN;
 204   1      
 205   1          return num;
 206   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1521    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    292    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
