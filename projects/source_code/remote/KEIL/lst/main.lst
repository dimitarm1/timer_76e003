C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Output\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\main.c LARGE OMF2 OPTIMIZE(1,SPEED) BROWSE INCDIR(..\..\..\..\Library
                    -\Device\Include;..\..\..\..\Library\StdDriver\inc) DEBUG PRINT(.\lst\main.lst) TABS(2) OBJECT(.\Output\main.obj)

line level    source

   1          /*--------------------------------------------------------------------------------------------------------
             --*/
   2          /*                                                                                                        
             - */
   3          /* SPDX-License-Identifier: Apache-2.0                                                                    
             - */
   4          /* Copyright(c) 2023 Nuvoton Technology Corp. All rights reserved.                                        
             - */
   5          /*                                                                                                        
             - */
   6          /*--------------------------------------------------------------------------------------------------------
             --*/
   7          #include "numicro_8051.h"
*** WARNING C320 IN LINE 576 OF \nuvoton\remote_keil\Library\Device\Include\function_define_N76E003.h: "Taken from other
             - CPU!!! May not work"
   8          
   9          /*
  10          //----------------------------------------------------------------------------------------------//
  11          void main (void)
  12          {
  13              // UART0 settting for printf function 
  14              MODIFY_HIRC(HIRC_166);
  15          //    Enable_UART0_VCOM_printf_166M_115200();
  16          //    printf ("\n Test start ...");
  17          
  18              ALL_GPIO_QUASI_MODE;
  19              P12_PUSHPULL_MODE;
  20              P13_INPUT_MODE;
  21          
  22              while(1)
  23              {
  24                P0 = ~P0;
  25                P1 = ~P1;
  26                P30 ^= 1;
  27                P1 |= SET_BIT2;
  28                if (!(P1&SET_BIT3))
  29                {
  30                  CALL_NOP;
  31                }
  32               
  33          
  34                P1 &= CLR_BIT2;
  35                if (P1&SET_BIT3)
  36                {
  37                  CALL_NOP;
  38                }
  39               
  40              }
  41          }
  42          
  43          */
  44          
  45          
  46          #include "led.h"
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 2   

  47          
  48          #define KEY_0_PRESSED  0x01
  49          #define KEY_1_PRESSED  0x02
  50          #define KEY_2_PRESSED  0x04
  51          #define KEY_3_PRESSED  0x08
  52          #define KEY_PRESSED    0x0F
  53          
  54          #define KEY_0_RELEASED 0x10
  55          #define KEY_1_RELEASED 0x20
  56          #define KEY_2_RELEASED 0x40
  57          #define KEY_3_RELEASED 0x80
  58          #define KEY_RELEASED   0xF0
  59          
  60          
  61          #define BUTTON_MINUS   0x01
  62          #define BUTTON_PLUS    0x02
  63          #define BUTTON_START   0x04
  64          #define BUTTON_STOP    0x08
  65          
  66          #define STATE_NONE          0
  67          #define STATE_WAITING       1
  68          #define STATE_WORKING       2
  69          #define STATE_COOLING       3
  70          #define STATE_DISPLAY_HOURS 4
  71          
  72          #define DEFAULT_COOL_TIME_SEC (3*60)
  73          #define DEFAULT_WAIT_TIME_SEC (9*60)
  74          #define ROLL_OVER_VALUE         336
  75          
  76          
  77          unsigned short keys_scan_buffer[4];
  78          unsigned char key_state;
  79          short counter = 0;
  80          int seconds_counter = 0;
  81          int pre_time;
  82          int main_time;
  83          int cool_time;
  84          U8 last_key;
  85          U8 new_key;
  86          U8 buzz_counter;
  87          U8 current_state;
  88          U8 finished;
  89          U8 refresh_display;
  90          
  91          
  92          typedef union {
  93            char data_bytes[4];
  94            int time;
  95          } timedata_t;
  96          
  97          timedata_t timedata;
  98          
  99          
 100          /********** current variant **********/
 101          /*
 102           * One digit:                          TABLE:
 103           *   ***A***                   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  -  h
 104           *   *     *         (F) PA1   0  1  1  1  0  0  0  1  0  0  0  0  0  1  0  0  1  0
 105           *   F     B         (B) PB4   0  0  0  0  0  1  1  0  0  0  0  1  1  0  1  1  1  1
 106           *   *     *         (A) PB5   0  1  0  0  1  0  0  0  0  0  0  1  0  1  0  0  1  1
 107           *   ***G***         (G) PC3   1  1  0  0  0  0  0  1  0  0  0  0  1  0  0  0  0  0
 108           *   *     *         (C) PC4   0  0  1  0  0  0  0  0  0  0  0  0  1  0  1  1  1  0
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 3   

 109           *   E     C         (DP)PC5   1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1
 110           *   *     *   **    (D) PC6   0  1  0  0  1  0  0  1  0  0  1  0  0  0  0  1  1  1
 111           *   ***D***  *DP*   (E) PC7   0  1  0  1  1  1  0  1  0  1  0  0  0  0  0  0  1  0
 112           *             **
 113           */
 114          
 115          /*
 116           * Number of digit on indicator with common anode
 117           * digis 0..3: PA3, PD6, PD4, PD1
 118           */
 119          
 120          /************* arrays for ports *************/
 121          //static const U8 LED_bits[18] = {0xfe,0x30,0xed,0xf9,0x33,0xdb,0xdf,0xf0,0xff,0xfb,
 122          //                          0xf7,0x3f,0x0d,0x3d,0xcf,0xe7,0x01,0};
 123          //
 124          //static U8 display_buffer[6] = {' ',' ',' ',' ',' ',' '}; // blank by default
 125          //U8 N_current = 0; // current digit to display
 126          
 127          unsigned char scan_keys(void)
 128          {
 129   1        unsigned char i, result = 0;
 130   1        keys_scan_buffer[0] = (keys_scan_buffer[0]<<1) | (!P15); // start)
 131   1        keys_scan_buffer[1] = (keys_scan_buffer[1]<<1) | (!P30); // stop
 132   1        keys_scan_buffer[2] = (keys_scan_buffer[2]<<1) | (!P07); // Dn
 133   1        keys_scan_buffer[3] = (keys_scan_buffer[3]<<1) | (!P13); // Up
 134   1        for(i = 0; i<4; i++)
 135   1        {
 136   2          if(keys_scan_buffer[i] == 0xffff)
 137   2          {
 138   3            if(!(key_state & (1<<i)))
 139   3            {
 140   4              key_state = key_state | (1<<i);
 141   4              result = result | (0x01<<i);
 142   4            }
 143   3          }
 144   2          if(keys_scan_buffer[i] == 0)
 145   2          {
 146   3            if((key_state & (1<<i)))
 147   3            {
 148   4              key_state = key_state & (~((unsigned char)(0x11<<i)));
 149   4      //        result = result | (0x10<<i);
 150   4            }
 151   3          }
 152   2      
 153   2        }
 154   1        return result;
 155   1      }
 156          
 157          
 158          void all_digits_off(void) {
 159   1          P12 = 0; // Digit 1
 160   1          P01 = 0; // Digit 2
 161   1          P04 = 0; // Digit 3
 162   1          P11 = 0; // Digit 4
 163   1          P03 = 0; // Digit 5
 164   1          P00 = 0; // Digit 6
 165   1      }
 166          
 167          
 168          // Unused
 169          void start_pressed() {
 170   1        
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 4   

 171   1        if(current_state == STATE_WAITING) {
 172   2          current_state = STATE_WORKING;
 173   2        }
 174   1        if(current_state == STATE_NONE) {
 175   2          if(pre_time) {
 176   3            current_state = STATE_WAITING;
 177   3          }
 178   2          else {
 179   3            display_int_sec(timedata.time);
 180   3          }
 181   2          return;
 182   2        }
 183   1      }
 184          
 185          
 186          #if defined __C51__
 187          void Timer0_ISR (void) interrupt 1              // vector=0x0B 
 188          
 189          #elif defined __ICC8051__
              #pragma vector=0x0B                             // Interrupt 1 
              __interrupt void Timer0_ISR(void)
              
              #elif defined __SDCC__
              void Timer0_ISR (void) __interrupt (1)          // vector=0x0B
              #endif
 196          {
 197   1          SFRS_TMP = SFRS;              /* for SFRS page */
 198   1          SFRS = 0;
 199   1      /* following setting for reload Timer 0 counter */
 200   1          TH0 = TH0TMP;
 201   1          TL0 = TL0TMP;
 202   1      /* following clear flag for next interrupt */
 203   1          clr_TCON_TF0;
 204   1          show_next_digit();
 205   1          counter++;
 206   1          if(buzz_counter) {
 207   2            buzz_counter--;
 208   2            if(!buzz_counter) {
 209   3              P05 = 1;
 210   3            }
 211   2          }
 212   1          if(counter > ROLL_OVER_VALUE) {
 213   2            counter = 0;
 214   2            
 215   2            //P14 ^= 1;
 216   2            if(current_state != STATE_NONE) {
 217   3              refresh_display = 1;
 218   3              if(pre_time) {
 219   4                pre_time--;
 220   4                if(!pre_time) {
 221   5                  if(main_time) {
 222   6                    current_state = STATE_WORKING;
 223   6                    P14 = 0; // Fan is on
 224   6                    P17 = 1; // Relay lampi is on
 225   6                  }
 226   5                  else {
 227   6                    if(!cool_time) {
 228   7                      cool_time = DEFAULT_COOL_TIME_SEC;
 229   7                    }
 230   6                    current_state = STATE_COOLING;
 231   6                  }
 232   5                }
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 5   

 233   4              }
 234   3              else if(main_time) {
 235   4                P17 = 1; // Lampi ON
 236   4                P14 = 0; // FAN ON
 237   4                main_time--;
 238   4                seconds_counter++;
 239   4                if(!main_time) {
 240   5                  if(!cool_time) {
 241   6                    cool_time = DEFAULT_COOL_TIME_SEC;
 242   6                  }
 243   5                  P17 = 0; // Relay lampi is off
 244   5                  current_state = STATE_COOLING;
 245   5                }
 246   4              }
 247   3              else if(cool_time) {
 248   4                P17 = 0; // Lampi OFF
 249   4                P14 = 0; // FAN ON
 250   4                cool_time--;
 251   4                if(!cool_time) {
 252   5                  P14 = 1; // Fan is off
 253   5                  // Write data to EEPROM
 254   5                  current_state = STATE_NONE;
 255   5                  finished = 1;
 256   5                }       
 257   4              }
 258   3              else {
 259   4                P17 = 0; // Lampi OFF
 260   4                P14 = 1; // FAN OFF
 261   4              }
 262   3            } 
 263   2          }
 264   1          if(refresh_display){
 265   2            refresh_display = 0;
 266   2            if(current_state == STATE_WORKING){
 267   3              display_int_sec(main_time);
 268   3            }
 269   2            else if(current_state == STATE_WAITING){
 270   3              display_int_sec(pre_time);
 271   3            }
 272   2            else if(current_state == STATE_COOLING){
 273   3              display_int_sec(cool_time);
 274   3            }
 275   2            else if(current_state == STATE_NONE){
 276   3              display_int_sec(0);
 277   3            }
 278   2          }
 279   1          
 280   1          if (SFRS_TMP)                 /* for SFRS page */
 281   1          {
 282   2            ENABLE_SFR_PAGE1;
 283   2          }
 284   1      }
 285          
 286          
 287          void main (void) 
 288          {
 289   1          unsigned char i;
 290   1          unsigned int j;
 291   1          MODIFY_HIRC(HIRC_16);
 292   1      
 293   1      
 294   1          seconds_counter = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 6   

 295   1          last_key = 0;
 296   1      
 297   1          ALL_GPIO_QUASI_MODE; // All GPIO are disabled
 298   1      
 299   1          P06_PUSHPULL_MODE; // Temporary serial clock
 300   1          P10_PUSHPULL_MODE; // Shift data out
 301   1      
 302   1          P14_PUSHPULL_MODE; // Led Fan (green)
 303   1      
 304   1          // Digits Common Anode
 305   1          P01_PUSHPULL_MODE; // Digit 1
 306   1          P12_PUSHPULL_MODE; // Digit 2
 307   1          P04_PUSHPULL_MODE; // Digit 3
 308   1          P11_PUSHPULL_MODE; // Digit 4
 309   1          P03_PUSHPULL_MODE; // Digit 5
 310   1          P00_PUSHPULL_MODE; // Digit 6
 311   1      
 312   1          P05_PUSHPULL_MODE; // Buzzer
 313   1          // Keyboard
 314   1          P15 = 1; // Key1
 315   1          P30 = 1; // Key2
 316   1          P07 = 1; // Key3
 317   1          P13 = 1; // Key4
 318   1          
 319   1          P14 = 1; // Fan off
 320   1          
 321   1          for(j = 0; j < 65535; j++) {
 322   2            P06 ^=1;
 323   2            P10 = (j&2)/2;
 324   2          }
 325   1          P02_PUSHPULL_MODE; // Real clock
 326   1          P17_PUSHPULL_MODE; // Led Lampi (red)
 327   1      
 328   1          all_digits_off();
 329   1          display_int(0);
 330   1      
 331   1          P12 = 1; // Digit 1
 332   1          P01 = 1; // Digit 2
 333   1          P04 = 1; // Digit 3
 334   1          P11 = 1; // Digit 4
 335   1          P03 = 1; // Digit 5
 336   1          P00 = 1; // Digit 6
 337   1      
 338   1          P10 = 0;
 339   1          for(i = 0; i < 16; i++) {
 340   2            P06 ^=1;
 341   2            P10 = (i&2)/2;
 342   2          }
 343   1      
 344   1          if(P15 && P30) { //new_key == (BUTTON_STOP | BUTTON_START)){
 345   2            // Reset counter in flash
 346   2            buzz_counter = 250;
 347   2            finished = 255;
 348   2          }
 349   1          else {
 350   2            finished = 0;
 351   2          }
 352   1          Timer0_AutoReload_Interrupt_Initial(24,2000);
 353   1          ENABLE_GLOBAL_INTERRUPT;
 354   1            
 355   1          while(1)
 356   1          {
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 7   

 357   2      
 358   2      
 359   2      //      display_int(counter++);
 360   2      
 361   2      //    P0 = ~P0;
 362   2      //    P1 = ~P1;
 363   2      //    P30 ^= 1;
 364   2      //      for(i = 0; i < 16; i++) {
 365   2      //        P06 ^=1;
 366   2      //      }
 367   2      //    P10 ^= 1;
 368   2      //    P04 ^= 1;
 369   2      //    P14 ^= 1;
 370   2            for(j = 0; j < 640; j++) {
 371   3              ;
 372   3            }
 373   2      
 374   2            new_key = scan_keys();
 375   2            if(new_key != last_key) {
 376   3              DISABLE_GLOBAL_INTERRUPT;
 377   3              last_key = new_key;
 378   3              if( new_key) {
 379   4      //          seconds_counter++;
 380   4                buzz_counter = 25;
 381   4                P05 = 0; // Buzzer on
 382   4                switch (new_key) {
 383   5                case BUTTON_START:
 384   5                {
 385   6                  if(current_state == STATE_NONE) {
 386   7                    if(main_time) {               
 387   8                      current_state = STATE_WAITING;
 388   8                      pre_time = DEFAULT_WAIT_TIME_SEC;
 389   8                      counter = ROLL_OVER_VALUE/4;
 390   8                      display_int_sec(pre_time);
 391   8                    }
 392   7                    else {
 393   8                  
 394   8                      // Read EEPROM
 395   8      #if defined __C51__
 396   8                      timedata.data_bytes[0] = Read_APROM_BYTE(0x38FB);
 397   8                      timedata.data_bytes[1] = Read_APROM_BYTE(0x38FC);
 398   8                      timedata.data_bytes[2] = Read_APROM_BYTE(0x38FD);
 399   8                      timedata.data_bytes[3] = Read_APROM_BYTE(0x38FE);
 400   8      #elif defined __ICC8051__
                              timedata.data_bytes[0] = Read_APROM_BYTE((uint16_t __code *)0x38FB);
                              timedata.data_bytes[1] = Read_APROM_BYTE((uint16_t __code *)0x38FC);
                              timedata.data_bytes[2] = Read_APROM_BYTE((uint16_t __code *)0x38FD);
                              timedata.data_bytes[3] = Read_APROM_BYTE((uint16_t __code *)0x38FE);
              #elif defined __SDCC__
                              timedata.data_bytes[0] = Read_APROM_BYTE((uint16_t __code*)0x38FB);
                              timedata.data_bytes[1] = Read_APROM_BYTE((uint16_t __code*)0x38FC);
                              timedata.data_bytes[2] = Read_APROM_BYTE((uint16_t __code*)0x38FD);
                              timedata.data_bytes[3] = Read_APROM_BYTE((uint16_t __code*)0x38FE);
              #endif
 411   8                      display_int_sec(timedata.time);
 412   8                    }
 413   7                  }
 414   6                  else if(current_state == STATE_WAITING) {
 415   7                    pre_time = 0;
 416   7                    current_state = STATE_WORKING;
 417   7                  }
 418   6                }           
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 8   

 419   5                break;
 420   5                case BUTTON_STOP:
 421   5                {
 422   6                  if(current_state == STATE_NONE || current_state == STATE_WAITING) {
 423   7                    pre_time = 0;
 424   7                    main_time = 0;
 425   7                    cool_time = 0;
 426   7                    current_state = STATE_NONE;
 427   7                    display_int_sec(main_time);
 428   7                  }
 429   6                  else if(current_state == STATE_WORKING) {
 430   7                    pre_time = 0;
 431   7                    main_time = 0;
 432   7                    current_state = STATE_COOLING;
 433   7                    cool_time = DEFAULT_COOL_TIME_SEC;
 434   7                    display_int_sec(cool_time);
 435   7                  }
 436   6                }
 437   5                break;
 438   5                case BUTTON_MINUS:
 439   5                {
 440   6                  if(current_state == STATE_NONE && main_time < 30*60) {
 441   7                    main_time = main_time + 60;
 442   7                    display_int_sec(main_time);
 443   7                  }
 444   6                }
 445   5                break;
 446   5                case BUTTON_PLUS:           
 447   5                {
 448   6                  if(current_state == STATE_NONE && main_time > 59) {
 449   7                    main_time = main_time - 60;
 450   7                    display_int_sec(main_time);
 451   7                  }
 452   6                }
 453   5                break;
 454   5                }
 455   4               
 456   4              }
 457   3               ENABLE_GLOBAL_INTERRUPT;
 458   3            }
 459   2            if(finished) {
 460   3      #if defined __C51__
 461   3              timedata.data_bytes[0] = Read_APROM_BYTE(0x38FB);
 462   3              timedata.data_bytes[1] = Read_APROM_BYTE(0x38FC);
 463   3              timedata.data_bytes[2] = Read_APROM_BYTE(0x38FD);
 464   3              timedata.data_bytes[3] = Read_APROM_BYTE(0x38FE);
 465   3      #elif defined __ICC8051__
                      timedata.data_bytes[0] = Read_APROM_BYTE((uint16_t __code *)0x38FB);
                      timedata.data_bytes[1] = Read_APROM_BYTE((uint16_t __code *)0x38FC);
                      timedata.data_bytes[2] = Read_APROM_BYTE((uint16_t __code *)0x38FD);
                      timedata.data_bytes[3] = Read_APROM_BYTE((uint16_t __code *)0x38FE);
              #elif defined __SDCC__
                      timedata.data_bytes[0] = Read_APROM_BYTE((uint16_t __code*)0x38FB);
                      timedata.data_bytes[1] = Read_APROM_BYTE((uint16_t __code*)0x38FC);
                      timedata.data_bytes[2] = Read_APROM_BYTE((uint16_t __code*)0x38FD);
                      timedata.data_bytes[3] = Read_APROM_BYTE((uint16_t __code*)0x38FE);
              #endif
 476   3              seconds_counter = timedata.time + seconds_counter/60;
 477   3              if(finished == 255 || seconds_counter == 0xFFFFFFFF) {
 478   4                timedata.time = 0;
 479   4              }
 480   3              else {
C51 COMPILER V9.60.7.0   MAIN                                                              09/29/2024 21:23:52 PAGE 9   

 481   4                timedata.time = seconds_counter;
 482   4              }
 483   3              Write_DATAFLASH_BYTE (0x38FB,timedata.data_bytes[0]);
 484   3              Write_DATAFLASH_BYTE (0x38FC,timedata.data_bytes[1]);
 485   3              Write_DATAFLASH_BYTE (0x38FD,timedata.data_bytes[2]);
 486   3              Write_DATAFLASH_BYTE (0x38FE,timedata.data_bytes[3]);
 487   3              finished = 0;
 488   3              seconds_counter = 0;
 489   3              P17 = 0; // Lampi OFF
 490   3              P14 = 1; // FAN OFF
 491   3            }
 492   2         }
 493   1      
 494   1      }
 495          
 496          
 497          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1918    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     34    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
